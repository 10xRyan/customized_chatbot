import os

from langchain.chains import LLMChain
from langchain.chat_models import ChatOpenAI
from langchain.memory import ConversationBufferMemory
from langchain.prompts import (
    ChatPromptTemplate,
    HumanMessagePromptTemplate,
    MessagesPlaceholder,
    SystemMessagePromptTemplate,
)

import threading
import time
from collections import deque
import random

import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

api_key = os.getenv('OPENAI_API_KEY')
client = ChatOpenAI(api_key=api_key)

username = os.getenv('user_name')
#usertype = os.getenv('user_type')

user_email = os.getenv('user_email')
user_email_password = os.getenv('user_email_password')

class ChatSession:
    llm: ChatOpenAI
    prompt: ChatPromptTemplate
    memory: ConversationBufferMemory
    conversation: LLMChain

    def __init__(self) -> None:
        self.llm = ChatOpenAI(
            model="gpt-3.5-turbo"
        )  # gpt-3.5-turbo you can use any model you want but bigger isn't always better
        self.prompt = ChatPromptTemplate.from_messages(
            messages=[
                SystemMessagePromptTemplate.from_template(
                    "You are a nice chatbot having a conversation with a human."  # You can change this to whatever you want
                ),
                # The `variable_name` here is what must align with memory
                MessagesPlaceholder(variable_name="chat_history"),
                HumanMessagePromptTemplate.from_template("{question}"),
            ]
        )
        self.memory = ConversationBufferMemory(
            memory_key="chat_history", return_messages=True
        )
        self.conversation = LLMChain(
            llm=self.llm, prompt=self.prompt, verbose=False, memory=self.memory
        )

    def chat(self, question: str) -> str:
        return self.conversation({"question": question})["text"]

    def get_conversation_string(self) -> str:
        return self.memory.buffer_as_str


def clear_term() -> None:
    os.system("cls||clear")

# Custom Function 1: retreiving the input
def get_input(input_queue):
    while True:
        input_queue.append(input())
    
# Custom Function 2: sending the email
# sender_email      str, user's email (needs to be set in the environment in the beginning)
# sender_password   str, user's email password (also needs to be set in the environment in the beginning)
# recipient_email   str, recipient's email
# subject           str, subject of the email
# body              str, body of the email
def send_email(sender_email = user_email, 
               sender_password = user_email_password, 
               recipient_email = "", email_subject = "", email_body= ""):
    server = smtplib.SMTP('smtp.office365.com', 587)
    server.starttls()
    server.login(sender_email, sender_password)

    message = MIMEMultipart()
    message["From"] = sender_email
    message["To"] = recipient_email
    message["Subject"] = email_subject
    message.attach(MIMEText(email_body, 'plain'))

    server.send_message(message)
    server.quit()

# Helper function for chekcing whether the respons from AI is a drafted email
# x                 list, splitted AI response
#
# returns           boolean, whether the response provided by AI contains a drafted email or not
#
#   AI usually (almost always) provides an email format with start word "Subject:"
def check(x):
    if "Subject:" in x:
        return True
    else:
        False

# Helper function for extracting the subject and body of the email drafted by AI
# x                 list, splitted AI response
#
# returns           tuple, (subject, body)
#   AI usually provides an email template starts with the word "Dear", and the body ends with word "[Your name]"
def decompose(x):
    subject_idx = x.index("Subject:")
    body_idx = x.index("Dear")
    end_idx = x.index("[Your")
    return (" ".join(x[subject_idx+1:body_idx]),
            " ".join(x[body_idx+3:end_idx]),)

# Reformat the email
# 
# username          str, set in environment
# name              str, recipent name
# body              str, provided by AI
#
# returns           str, a normal email format
def reformat_email(username, name, body):
    return f'''Dear {name}:

{body}

Best Regards, 
{username}'''

# Record dialogues into a local file
# respond           str, respond generated by both of AI and Human
# file_path         str, the file_path to record the dialogue
def record(respond, file_path):
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(respond + '\n')

# Erase everythin in the local file
def erase(file_name):
    with open(file_name, 'w', encoding='utf-8'):
        pass

### MAIN FUNCTION
def main(resume_from_a_chat, history_path="") -> None:
    chat_session = ChatSession()
    input_timeout = 60  # If the conversation remains idle for this time, automatically close the conversation (in seconds)
    input_queue = deque()
    count = 0

    if resume_from_a_chat:
        with open(history_path, 'r', encoding='utf-8') as file:
            content = file.read()
        chat_session.chat(f"let's review what we talk during our last chat based on this dialogue: ({content})")
        count = 1
    
    input_thread = threading.Thread(target=get_input, args=(input_queue,))
    input_thread.daemon = True
    input_thread.start()
    wait_for_email_response = False

    while True:
        count += 1
        clear_term()
        
        if count == 1:
            print("Type anything to start: ")
        
        
        # if count == 5:
        #     print("Please subscribed premium to unlock")
        #     return
        
        output = chat_session.get_conversation_string()
        record(output, history_path)
        print(output)
        
        if not resume_from_a_chat and check(output.split()):
            print("Do you satisfy with this? If yes, please reply in this format: yes,name_of_recipient,username@address.com")
            wait_for_email_response = True
        resume_from_a_chat = False
        start_time = time.time()
        while True:
                
            if input_queue:  # If Human entered a question in time, fetch the question from the deque and break the inner while loop
                user_query = input_queue.popleft()
                if wait_for_email_response:
                    temp = user_query.split(',')
                    if temp[0] == "yes":
                        subject, body = decompose(output.split())
                        receiver = temp[2]
                        name = temp[1]
                        content = reformat_email(username, name, body)
                        send_email(recipient_email=receiver,email_subject=subject,email_body=content)
                        print("Already Sent!!!")
                        return
                    else:
                        break
                else:
                    break

            if time.time() - start_time > input_timeout: # If 
                print("\nSession timed out.")
                return
                

        if user_query.lower().strip() in {"exit", "quit"}:
            break
        
        record(user_query, history_path)
        chat_session.chat(user_query)
        #time.sleep(random.uniform(1,5)) # VIP Buffer

# Basic Logic for the beginning phase:
#       First: check whether the history folder contains any history dialogue
#           IF YES -> Ask the user whether they want to continue the discussion of any of them
#                    IF YES -> List all of the previous dialogues and let the user to choose one of them
#                    IF NO -> Start a new conversation and ask the user to name the conversation
#           IF NO -> Start a new conversation and ask the user to name the conversation
if __name__ == "__main__":
    current_working_directory = os.getcwd()
    full_path = os.path.join(current_working_directory, 'history')
    txt_files = [file for file in os.listdir(full_path) if file.endswith('.txt')]
    if txt_files:
        print('I noticed that there is a previous chat history between us. Do you want to continue on any of these session?')
        answer = input("[ENTER yes or no]: ")
        if answer == "yes":
            for index, file in enumerate(txt_files, start=1):
                print(f"{index}. {file}")
            idx = input("Please enter the number of the session you want to open: ")
            main(True, f'history/{txt_files[int(idx)-1]}')
        else:
            file_name = input("Please give a name of your session with BOT: ")
            main(False, f"history/{file_name}.txt")
    else:
        file_name = input("Please give a name of your session with BOT: ")
        main(False, f"history/{file_name}.txt")
